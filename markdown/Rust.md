# Rust

- https://employment.en-japan.com/engineerhub/entry/2017/07/10/110000
- https://speakerdeck.com/qnighy/rustsu-xi-hui-1
- http://keens.github.io/slide/rustnokoremadetokorekara/
- http://nihaoshijie.hatenadiary.jp/entry/2017/10/24/021537
- http://uchan.hateblo.jp/entry/2018/08/24/234334
- https://qiita.com/okeguch/items/1f9b7e6367e8292f646f
- http://golang.rdy.jp/2017/12/20/go-fact/
- 実践的なアプリケーションを書いてみよう！ Rustの構造化プログラミング【第二言語としてのRust】
    - https://employment.en-japan.com/engineerhub/entry/2017/07/19/110000
- [Rust初心者が参考になった記事](https://qiita.com/ayase/items/7e32a920cbc5d6542d6b)

### ドキュメント
- [The Rust Programming Language](https://doc.rust-lang.org/book/)
- [Rustの日本語ドキュメント/Japanese Docs for Rust](https://doc.rust-jp.rs/)
    - [プログラミング言語 Rust, 2nd Edition](https://doc.rust-jp.rs/book/second-edition/)
        - 最新の日本語ドキュメント
        - 1.6と1.9は古いのでこっちを見る
        - second-editionよりも新しい2018ってのもあるが翻訳されていない
    - [Rust by Example](https://doc.rust-jp.rs/rust-by-example-ja/)
        - サンプルコードで学ぶやつ




所有権
- メモリは、コンパイラがコンパイル時にチェックする一定の規則とともに所有権システムを通じて管理される
- どの所有権機能も、実行中にプログラムの動作を遅くすることはない

スタックとヒープ
- システムプログラミング言語においては、値がスタックに載るかヒープに載るかは重要なこと
- スタックもヒープも、実行時にコードが使用できるメモリの一部
    - スタックは後入れ先出し(Last in, First Out)の構造
    - スタックにデータを追加することをpush、スタックから取り出すことをpopという
- スタックは高速
- 新しいデータを置いたり、データを取得する場所を探す必要がない
    - なぜなら、その場所は常に1番上だから
- スタック上のデータは全て基地の固定サイズにならなければならない
    - これもスタックを高速にしている特性
- コンパイル時にサイズがわからなかったり、サイズが可変のデータについては、代わりにヒープに格納する
- ヒープはスタックに比べてももっとごちゃごちゃしている
    - ヒープにデータを置く時、あるサイズのスペースを求める
    - OSはヒープ状に十分な大きさのからの領域を見つけ、使用中にし、ポインタを返す
    - ポインタとは、その場所へのアドレスのこと
    - この過程は、ヒープに領域を確保すると呼ばれる
    - allocateするとも呼ばれる
- スタックに値を載せることは、メモリ確保とは言えない
- ポインタは、基地の固定サイズなので、スタックに保管することができるが、実データが必要になったら、ポインタを追いかける必要がある
- レストランの例え
- ヒープへのデータアクセスは、スタックのデータへのアクセスよりも低速
    - ポインタを追って目的の場所に到達しなければならないから
- データが隔離されている(ヒープではそうなっている可能性がある)よりも、近くにある(スタックではこうなる)方が速い
- ヒープに大きな領域を確保する行為も時間がかかることがある
- コードが関数を呼び出すと、以下のものがスタックに載る
    - 関数に渡された値(ヒープのデータへのポインタも含まれる可能性あり)
    - 関数のローカル変数
- 関数の実行が終了すると、それらの値はスタックから取り除かれる

- 以下は全て所有権が解決する問題
- どの部分のコードがどのヒープ上のデータを使用しているか把握すること
- ヒープ上の重複するデータを最小化すること
- メモリ不足にならないようにヒープ上の未使用のデータを掃除すること

所有権のルール
- Rustの各値は、**所有者**と呼ばれる変数と対応している
- いかなる時も所有者は一つである
- 所有者がスコープから外れたら、値は破棄される


- プリミティブ型などはスタックに保管される
- String型などの参照型はヒープに確保される
- String型はヒープにメモリを確保するので、コンパイル時にはサイズが不明なテキストも保持することができる

`from`関数を使用して、文字列リテラルから`String`型を生成できる。
```rust
let s = String::from("hello");
```

この種の文字列は可変化することができる。
```rust
let s = String::from("hello");

s.push_str(", world!"); // push_str()関数は、リテラルをStringに付け加える

println!("{}", s);  // => hello, world!
```

ここでの違いは何？なぜ`String`型は可変化できるのに、リテラルはできないのか？

違いは、これら二つの型がメモリを扱う方法にある。
- 文字列リテラルは、中身はコンパイル時に判明しているので、テキストは最終的なバイナリファイルに直接ハードコードされる
- このため文字列リテラルは、高速で効率的になる
- しかしこれらの特性は、その文字列リテラルの不変性にのみ端を発する
    - コンパイル時にサイズが不明だったり、プログラム実行に合わせてサイズが可変なテキスト片用に一回のメモリをバイナリに確保して置くことは不可能

- `String`型では、可変かつ身長可能なテキスト破片をサポートするために、コンパイル時には不明な量のメモリをヒープに確保して内容を保持する
    - つまり、
    - メモリは、実行時にOSに要求される
    - `String`型を使用し終わったら、OSにこのメモリを返還する方法が必要である
- 最初の部分は、`String::from`関数で行われる。
- これを呼ぶと、その実装が必要なメモリを要求する。これはプログラミング言語におていはよくあるもの
- ２番目の部分は違う。(普遍的ではない)
- ガベージコレクタ付きの言語では、GCがこれ以上使用されないメモリを検知して片付けるため、プログラマはそのことを考慮する必要はない
- GCがないなら、メモリがもう使用されないことを見計らって、明示的に返還するコードを呼び出すのはプログラマの責任になる(要求の時と同じように)
- しかしこれを正確に行うことは難しい
    - もし返還を忘れるとメモリを無駄にする
    - もし返還のタイミングが早すぎたら、無効な変数を作ってしまう
    - 2回解放してしまってもバグになる
    - allocateとfreeは一対一対応にしなければならない
- Rustではこれらとは違った方法を採用している
- メモリを所有している変数がスコープを抜けたら、メモリは自動的に返還される
- 変数がスコープを抜けるとき、特別な関数`drop`を読んでくれる
- その`drop`関数でメモリ返還するコードを配置することができる
- Rustは閉じ波括弧で自動的に`drop`関数を呼び出してくれる


#### ムーブ

```rust
let x = 5;
let y = x;
```
これはこんな感じ
- 値`5`を`x`に束縛する
- それから`x`の値をコピーして`y`に束縛する

二つの変数xとyが存在し、両方とも値は`5`になった。整数は既知の固定サイズの単純な値で、これら二つの`5`という値はスタックに積まれる。



```rust
let s1 = String::from("hello");
let s2 = s1;

println!("{}", s1); // => コンパイルエラー
```
これは、`s1`の値をコピーして`s2`に束縛しているわけではない。

`String`型は次の３つの部品でできている。
- 文字列の中身を保持するメモリへのポインタ
- 文字列の長さ
- 許容量
これらのデータはスタックに保持される。
そしてポインタが指す先に、中身を保持したヒープ上のメモリがある。

- `s2`を`s1`に代入すると、`String`型のデータがコピーされる
- つまり、スタックにあるポインタ、長さ、許容量をコピーするということ
- ポインタが指すヒープ上のデータはコピーしない
- つまり`s1`と`s2`の両方が、同じヒープ上のメモリにある`hello`というデータを指している
- ここで、`s1`を使おうとするとコンパイルエラーになる
- `s2`に代入した時点で、`s1`はもはや有効な変数ではないとみなされるため
- データをコピーせず、ポインタと長さと許容量をコピーするというのは`shallow copy`動作のように思えるがそれとは異なっている
- 変数そのものも無効化するので`move`と呼ばれている
- `s1`は`s2`にムーブされた、という感じ

- つまり、Rustでは自動的にデータの`deep copy`が行われることは絶対にない
- ゆえに、あらゆる自動コピーは、実行時性能的に悪くはない


#### クローン

スタック上のデータだけでなく、本当に`String`型のヒープデータのdeep copyが必要なら`clone`メソッドを使う

```rust
let s1 = String::from("hello");
let s2 = s1.clone();

println!("s1 = {}, s2 = {}", s1, s2);
```

`clone()`を使うと、ヒープデータが実際にコピーされる。実行コストは安くはない。

---

- 値を渡す
    - 渡すとムーブするので、そのあとに値を参照すらできない
    - 当然、値を変更できない
- 参照を渡す(`&x`)
    - ムーブしないので、そのあと値を再度参照できる
    - しかし値は変更できない
- 可変の参照を渡す(`&mut x`)
    - ムーブしない
    - 値を変更できる




しかし、同じスコープ内に可変の参照はひとつしか存在できないという制限がある。

```rust
let mut s = String::from("hello");

let r1 = &mut s;    // ひとつめの可変の参照
let r2 = &mut s;    // ふたつめ

//=> コンパイルエラーになる
```

これはデータの競合をコンパイル時に防ぐため。
データ競合とは、競合条件と類似していて、次の３つの振る舞いが起きるときに発生する
- ２つ以上のポインタが同じデータに同時にアクセスする
- 少なくとも一つのポインタがデータに書き込みを行なっている
- データへのアクセスを同期する機構が使用されていない

Rustでは、このようなデータ競合が起こるコードをコンパイルさえさせてくれない。


波括弧を使ってスコープを分ければ複数の可変な参照を作ることができる。

```rust
let mut s = String::from("hello");

{

    let r1 = &mut s;

}   // r1はここでスコープを抜けるので、問題なく新しい参照を作ることができる

let r2 = &mut s;
```


---

文字列リテラルはスライスである
```rust
let s = "Hello, world!";
```
ここでの`s`の型は、`&str`になる。バイナリのその特定の位置を指すスライス。これは文字列が不変である理由にもなっている。要するに、`&str`は不変な参照である。

```rust
// 引数の型をスライス(&str)にすることで、
// String値と&str値の両方に使えるより一般的なものにすることができる
fn first_word3(s: &str) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}

fn main() {
    let my_string = String::from("hello world");

    // first_word3はStringのスライスに対して機能する
    let word = first_word3(&my_string[..]);


    let my_string_literal = "hello world";

    // first_word3は文字列リテラルのスライスに対して機能する
    let word = first_word3(&my_string_literal[..]);

    // 文字列リテラルはすでに文字列スライスなので
    // スライス記法なしでも機能する
    let word = first_word3(my_string_literal);
}
```


当然、文字列リテラル以外にもスライス型が存在する。例えば配列のスライス。
```rust
let a = [1, 2, 3, 4, 5];

let slice = &a[1..3];

println!("{:?}", slice);    // => [2, 3]
```

このスライスは、最初の要素への参照と長さを保持する。


---
### 構造体

`User`構造体を定義するとき、`&str`文字列スライス型ではなく、所有権のある`String`型を使ったのには理由がある。
この構造体のインスタンスには全データを所有してもらう必要があり、子のデータは、構造体全体が有効な間はずっと有効である必要がある。

構造体に、他の何かに所有されたデータへの参照を保持させることもできるが、そうするにはライフタイムという機能を使用しなければならない。

ライフタイムのおかげで、構造体に参照されたデータが、構造体自体が有効な間、ずっと有効であることを保証してくれる。

ライフタイムを指定せずに構造体に参照を保持させようとすると、コンパイルエラーになる
```rust
struct User2 {
    username: &str,
    email: &str,
    sign_in_count: u64,
    active: bool,
}

// error: missing lifetime specifier(ライフタイム指定子がありません)
```




---
`&[T]`や`&str`のような参照に対して**スライス**という言葉を使うことがよくあるが、
これはある種の省略形であり、本来は**スライスへの参照**と呼ぶべきもの。

