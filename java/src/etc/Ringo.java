package etc;

/**
 * M個のリンゴをN人で分けるとき、分け方が何通りあるか？
 *
 * https://www.slideshare.net/chokudai/wap-atcoder2
 */
public class Ringo {
    public static void main(String[] args) {

        System.out.println(dfs(3,3));

        System.out.println(solve(10,3));

    }

    // とりあえずこんな感じで書く
    // 「この関数を使えば、M個のリンゴをN人で分けたときの組み合わせの数がわかる」
    // という前提を置く。(ここ重要)
    static int dfs(int m, int n) {
        if (n == 1) {
            // リンゴを配るべき人が１人しかいない。
            // つまりその１人にすべてのリンゴをあげるしかない。
            // よって１パターンという結果を返す。
            return 1;
        }
        // リンゴを配るべき人が２人以上いるとき。
        // 例えばN=2のとき、１人への配り方を決めれば、もう１人への配り方も決まる(余りを配る)。
        // 2人のときはM個のリンゴならM+1パターンある。(0個配る場合もある)
        // 次にN=3のとき、2人への配り方を決まればもう1人への配り方も決まる(2人のときは↑のようにやる)
        // つまり、3人のときは2人への配り方を決めればよく、2人のときは1人への配り方を決めればよい。
        // そうやってひとりずつNを減らしていって、
        // N=2まで減らしたときにM個のリンゴの配り方を数えてその総和を取れば求める答えばわかる。
        int ret = 0;
        for (int i = 0; i <= m; i++) {
            ret += dfs(m - i, n - 1);
        }
        return ret;
    }

    // 数学的な解法
    static int solve(int m, int n) {
        // 例えば、m=5, n=3のとき
        // 5個のリンゴと、２本の棒の並びを考える。
        // ●|●●|●●の場合、1個・２個・２個と分けることを表現している
        // |●●|●●●の場合、0個・２個・３個と分けることを表現している
        // つまり、5個の●と2本の|の並びを考えればいい(同じものを含む順列)
        // この場合は、7!/(5!*2!)=21
        // 一般化すると、(m+n-1)!/(m!*(n-1)!)となる


        int x = 1;
        for (int i = 1; i <= m + n - 1; i++) {
            x *= i;
        }

        int y = 1;
        for (int i = 1; i <= m; i++) {
            y *= i;
        }

        int z = 1;
        for (int i = 1; i <= n - 1; i++) {
            z *= i;
        }


        return x / (y * z);
    }


}