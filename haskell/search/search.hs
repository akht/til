--与えられた値がリストのリストに含まれているかどうかを判定する

import Data.List

-- 深さ優先
dfs :: Int -> [[Int]] -> Bool
dfs x = elem x . concat


-- 幅優先
bfs :: Int -> [[Int]] -> Bool
bfs x = elem x . concat . transpose


-- xs = [[1,2,3], [4,5,6], [7,8,9]]という探索対象があった場合
-- 深さ優先探索だと
-- 最初のリスト[1,2,3]を探索
-- 次のリスト[4,5,6]を探索
-- 次のリスト[7,8,9]を探索としていくので
-- 1,2,3,4,5,6,7,8,9の順番で探索が進んでいく
-- つまり深さ優先探索だと、どこかに無限リストがあった場合はそこで探索が終わらないので、次のリストに到達することができない

-- 幅優先探索だと
-- 各リストの最初の要素、各リストの2番目の要素、各リストの3番目の要素...と探索していくので
-- 1,4,7,2,5,6,3,6,9の順番で探索が進んでいく
-- 幅優先探索の場合だと、どこかに無限リストがあってもすべてのリストを探索することはできる(無限リスト自体の探索は当然終わらない)

-- 実装としては、深さ優先探索はリスト中のリストをそのままひとつのリストにしてしまえばいい
-- それにはconcat関数を使う

-- concat関数
-- リスト中の要素を繋ぎ合わせる関数
-- > concat ["aa", "bb", "cc"]
-- > "aabbcc"
-- > concat [[1,2], [3,4,5]]
-- >[1,2,3,4,5]

-- 幅優先探索の実装は、各リストのn番目の要素を集めたリストを生成してそれを順番に探索すればいい
-- それにはtranspose関数を使う

-- transpose関数
-- 「転置」する関数
-- ２次元配列の行と列を入れ替える
-- [
--  [1, 2, 3]
--  [4, 5, 6]
-- ]
-- > transpose [[1,2,3], [4,5,6]]
-- > [[1,4], [2,5], [3,6]]
-- > transpose ["aa", "bb", "cc"]
-- > ["abc","abc"]



-- 動作を確認してみると、
-- xs = [[10..], [4,5,6], [7,8,9]]のように無限リストを含んでいる場合

-- 幅優先探索だと答えが返ってくる(３つ目のリストの9にたどり着く)
-- > bfs 9 xs
-- > True

-- 深さ優先探索だと最初に無限リストがあるので探索が終わらないので結果が返ってこない(３つ目のリストにたどり着かない)
-- > dfs 9 xs
-- > (返ってこない)

